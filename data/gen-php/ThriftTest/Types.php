<?php
namespace ThriftTest;

/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


/**
 * Docstring!
 */
final class Numberz {
  const ONE = 1;
  const TWO = 2;
  const THREE = 3;
  const FIVE = 5;
  const SIX = 6;
  const EIGHT = 8;
  static public $__names = array(
    1 => 'ONE',
    2 => 'TWO',
    3 => 'THREE',
    5 => 'FIVE',
    6 => 'SIX',
    8 => 'EIGHT',
  );
}

class Bonk {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;
  /**
   * @var int
   */
  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'Bonk';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Bonk');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 2);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Bools {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $im_true = null;
  /**
   * @var bool
   */
  public $im_false = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'im_true',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'im_false',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['im_true'])) {
        $this->im_true = $vals['im_true'];
      }
      if (isset($vals['im_false'])) {
        $this->im_false = $vals['im_false'];
      }
    }
  }

  public function getName() {
    return 'Bools';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->im_true);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->im_false);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Bools');
    if ($this->im_true !== null) {
      $xfer += $output->writeFieldBegin('im_true', TType::BOOL, 1);
      $xfer += $output->writeBool($this->im_true);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->im_false !== null) {
      $xfer += $output->writeFieldBegin('im_false', TType::BOOL, 2);
      $xfer += $output->writeBool($this->im_false);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Xtruct {
  static $_TSPEC;

  /**
   * @var string
   */
  public $string_thing = null;
  /**
   * @var int
   */
  public $byte_thing = null;
  /**
   * @var int
   */
  public $i32_thing = null;
  /**
   * @var int
   */
  public $i64_thing = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'string_thing',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'byte_thing',
          'type' => TType::BYTE,
          ),
        9 => array(
          'var' => 'i32_thing',
          'type' => TType::I32,
          ),
        11 => array(
          'var' => 'i64_thing',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['string_thing'])) {
        $this->string_thing = $vals['string_thing'];
      }
      if (isset($vals['byte_thing'])) {
        $this->byte_thing = $vals['byte_thing'];
      }
      if (isset($vals['i32_thing'])) {
        $this->i32_thing = $vals['i32_thing'];
      }
      if (isset($vals['i64_thing'])) {
        $this->i64_thing = $vals['i64_thing'];
      }
    }
  }

  public function getName() {
    return 'Xtruct';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->string_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->byte_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->i32_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->i64_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xtruct');
    if ($this->string_thing !== null) {
      $xfer += $output->writeFieldBegin('string_thing', TType::STRING, 1);
      $xfer += $output->writeString($this->string_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->byte_thing !== null) {
      $xfer += $output->writeFieldBegin('byte_thing', TType::BYTE, 4);
      $xfer += $output->writeByte($this->byte_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32_thing !== null) {
      $xfer += $output->writeFieldBegin('i32_thing', TType::I32, 9);
      $xfer += $output->writeI32($this->i32_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i64_thing !== null) {
      $xfer += $output->writeFieldBegin('i64_thing', TType::I64, 11);
      $xfer += $output->writeI64($this->i64_thing);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Xtruct2 {
  static $_TSPEC;

  /**
   * @var int
   */
  public $byte_thing = null;
  /**
   * @var \ThriftTest\Xtruct
   */
  public $struct_thing = null;
  /**
   * @var int
   */
  public $i32_thing = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'byte_thing',
          'type' => TType::BYTE,
          ),
        2 => array(
          'var' => 'struct_thing',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Xtruct',
          ),
        3 => array(
          'var' => 'i32_thing',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['byte_thing'])) {
        $this->byte_thing = $vals['byte_thing'];
      }
      if (isset($vals['struct_thing'])) {
        $this->struct_thing = $vals['struct_thing'];
      }
      if (isset($vals['i32_thing'])) {
        $this->i32_thing = $vals['i32_thing'];
      }
    }
  }

  public function getName() {
    return 'Xtruct2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->byte_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->struct_thing = new \ThriftTest\Xtruct();
            $xfer += $this->struct_thing->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->i32_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xtruct2');
    if ($this->byte_thing !== null) {
      $xfer += $output->writeFieldBegin('byte_thing', TType::BYTE, 1);
      $xfer += $output->writeByte($this->byte_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->struct_thing !== null) {
      if (!is_object($this->struct_thing)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('struct_thing', TType::STRUCT, 2);
      $xfer += $this->struct_thing->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32_thing !== null) {
      $xfer += $output->writeFieldBegin('i32_thing', TType::I32, 3);
      $xfer += $output->writeI32($this->i32_thing);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Xtruct3 {
  static $_TSPEC;

  /**
   * @var string
   */
  public $string_thing = null;
  /**
   * @var int
   */
  public $changed = null;
  /**
   * @var int
   */
  public $i32_thing = null;
  /**
   * @var int
   */
  public $i64_thing = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'string_thing',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'changed',
          'type' => TType::I32,
          ),
        9 => array(
          'var' => 'i32_thing',
          'type' => TType::I32,
          ),
        11 => array(
          'var' => 'i64_thing',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['string_thing'])) {
        $this->string_thing = $vals['string_thing'];
      }
      if (isset($vals['changed'])) {
        $this->changed = $vals['changed'];
      }
      if (isset($vals['i32_thing'])) {
        $this->i32_thing = $vals['i32_thing'];
      }
      if (isset($vals['i64_thing'])) {
        $this->i64_thing = $vals['i64_thing'];
      }
    }
  }

  public function getName() {
    return 'Xtruct3';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->string_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->changed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->i32_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->i64_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xtruct3');
    if ($this->string_thing !== null) {
      $xfer += $output->writeFieldBegin('string_thing', TType::STRING, 1);
      $xfer += $output->writeString($this->string_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->changed !== null) {
      $xfer += $output->writeFieldBegin('changed', TType::I32, 4);
      $xfer += $output->writeI32($this->changed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32_thing !== null) {
      $xfer += $output->writeFieldBegin('i32_thing', TType::I32, 9);
      $xfer += $output->writeI32($this->i32_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i64_thing !== null) {
      $xfer += $output->writeFieldBegin('i64_thing', TType::I64, 11);
      $xfer += $output->writeI64($this->i64_thing);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Insanity {
  static $_TSPEC;

  /**
   * @var array
   */
  public $userMap = null;
  /**
   * @var \ThriftTest\Xtruct[]
   */
  public $xtructs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'userMap',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::I64,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'xtructs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ThriftTest\Xtruct',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['userMap'])) {
        $this->userMap = $vals['userMap'];
      }
      if (isset($vals['xtructs'])) {
        $this->xtructs = $vals['xtructs'];
      }
    }
  }

  public function getName() {
    return 'Insanity';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->userMap = array();
            $_size0 = 0;
            $_ktype1 = 0;
            $_vtype2 = 0;
            $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $key5 = 0;
              $val6 = 0;
              $xfer += $input->readI32($key5);
              $xfer += $input->readI64($val6);
              $this->userMap[$key5] = $val6;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->xtructs = array();
            $_size7 = 0;
            $_etype10 = 0;
            $xfer += $input->readListBegin($_etype10, $_size7);
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $elem12 = null;
              $elem12 = new \ThriftTest\Xtruct();
              $xfer += $elem12->read($input);
              $this->xtructs []= $elem12;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Insanity');
    if ($this->userMap !== null) {
      if (!is_array($this->userMap)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userMap', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::I32, TType::I64, count($this->userMap));
        {
          foreach ($this->userMap as $kiter13 => $viter14)
          {
            $xfer += $output->writeI32($kiter13);
            $xfer += $output->writeI64($viter14);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->xtructs !== null) {
      if (!is_array($this->xtructs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('xtructs', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->xtructs));
        {
          foreach ($this->xtructs as $iter15)
          {
            $xfer += $iter15->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CrazyNesting {
  static $_TSPEC;

  /**
   * @var string
   */
  public $string_field = null;
  /**
   * @var \ThriftTest\Insanity[]
   */
  public $set_field = null;
  /**
   * @var (array)[]
   */
  public $list_field = null;
  /**
   * @var string
   */
  public $binary_field = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'string_field',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'set_field',
          'type' => TType::SET,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ThriftTest\Insanity',
            ),
          ),
        3 => array(
          'var' => 'list_field',
          'type' => TType::LST,
          'etype' => TType::MAP,
          'elem' => array(
            'type' => TType::MAP,
            'ktype' => TType::SET,
            'vtype' => TType::MAP,
            'key' => array(
              'type' => TType::SET,
              'etype' => TType::I32,
              'elem' => array(
                'type' => TType::I32,
                ),
            ),
            'val' => array(
              'type' => TType::MAP,
              'ktype' => TType::I32,
              'vtype' => TType::SET,
              'key' => array(
                'type' => TType::I32,
              ),
              'val' => array(
                'type' => TType::SET,
                'etype' => TType::LST,
                'elem' => array(
                  'type' => TType::LST,
                  'etype' => TType::MAP,
                  'elem' => array(
                    'type' => TType::MAP,
                    'ktype' => TType::STRUCT,
                    'vtype' => TType::STRING,
                    'key' => array(
                      'type' => TType::STRUCT,
                      'class' => '\ThriftTest\Insanity',
                    ),
                    'val' => array(
                      'type' => TType::STRING,
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        4 => array(
          'var' => 'binary_field',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['string_field'])) {
        $this->string_field = $vals['string_field'];
      }
      if (isset($vals['set_field'])) {
        $this->set_field = $vals['set_field'];
      }
      if (isset($vals['list_field'])) {
        $this->list_field = $vals['list_field'];
      }
      if (isset($vals['binary_field'])) {
        $this->binary_field = $vals['binary_field'];
      }
    }
  }

  public function getName() {
    return 'CrazyNesting';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->string_field);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::SET) {
            $this->set_field = array();
            $_size16 = 0;
            $_etype19 = 0;
            $xfer += $input->readSetBegin($_etype19, $_size16);
            for ($_i20 = 0; $_i20 < $_size16; ++$_i20)
            {
              $elem21 = null;
              $elem21 = new \ThriftTest\Insanity();
              $xfer += $elem21->read($input);
              if (is_scalar($elem21)) {
                $this->set_field[$elem21] = true;
              } else {
                $this->set_field []= $elem21;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->list_field = array();
            $_size22 = 0;
            $_etype25 = 0;
            $xfer += $input->readListBegin($_etype25, $_size22);
            for ($_i26 = 0; $_i26 < $_size22; ++$_i26)
            {
              $elem27 = null;
              $elem27 = array();
              $_size28 = 0;
              $_ktype29 = 0;
              $_vtype30 = 0;
              $xfer += $input->readMapBegin($_ktype29, $_vtype30, $_size28);
              for ($_i32 = 0; $_i32 < $_size28; ++$_i32)
              {
                $key33 = array();
                $val34 = array();
                $key33 = array();
                $_size35 = 0;
                $_etype38 = 0;
                $xfer += $input->readSetBegin($_etype38, $_size35);
                for ($_i39 = 0; $_i39 < $_size35; ++$_i39)
                {
                  $elem40 = null;
                  $xfer += $input->readI32($elem40);
                  if (is_scalar($elem40)) {
                    $key33[$elem40] = true;
                  } else {
                    $key33 []= $elem40;
                  }
                }
                $xfer += $input->readSetEnd();
                $val34 = array();
                $_size41 = 0;
                $_ktype42 = 0;
                $_vtype43 = 0;
                $xfer += $input->readMapBegin($_ktype42, $_vtype43, $_size41);
                for ($_i45 = 0; $_i45 < $_size41; ++$_i45)
                {
                  $key46 = 0;
                  $val47 = array();
                  $xfer += $input->readI32($key46);
                  $val47 = array();
                  $_size48 = 0;
                  $_etype51 = 0;
                  $xfer += $input->readSetBegin($_etype51, $_size48);
                  for ($_i52 = 0; $_i52 < $_size48; ++$_i52)
                  {
                    $elem53 = null;
                    $elem53 = array();
                    $_size54 = 0;
                    $_etype57 = 0;
                    $xfer += $input->readListBegin($_etype57, $_size54);
                    for ($_i58 = 0; $_i58 < $_size54; ++$_i58)
                    {
                      $elem59 = null;
                      $elem59 = array();
                      $_size60 = 0;
                      $_ktype61 = 0;
                      $_vtype62 = 0;
                      $xfer += $input->readMapBegin($_ktype61, $_vtype62, $_size60);
                      for ($_i64 = 0; $_i64 < $_size60; ++$_i64)
                      {
                        $key65 = new \ThriftTest\Insanity();
                        $val66 = '';
                        $key65 = new \ThriftTest\Insanity();
                        $xfer += $key65->read($input);
                        $xfer += $input->readString($val66);
                        $elem59[$key65] = $val66;
                      }
                      $xfer += $input->readMapEnd();
                      $elem53 []= $elem59;
                    }
                    $xfer += $input->readListEnd();
                    if (is_scalar($elem53)) {
                      $val47[$elem53] = true;
                    } else {
                      $val47 []= $elem53;
                    }
                  }
                  $xfer += $input->readSetEnd();
                  $val34[$key46] = $val47;
                }
                $xfer += $input->readMapEnd();
                $elem27[$key33] = $val34;
              }
              $xfer += $input->readMapEnd();
              $this->list_field []= $elem27;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->binary_field);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CrazyNesting');
    if ($this->string_field !== null) {
      $xfer += $output->writeFieldBegin('string_field', TType::STRING, 1);
      $xfer += $output->writeString($this->string_field);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->set_field !== null) {
      if (!is_array($this->set_field)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('set_field', TType::SET, 2);
      {
        $output->writeSetBegin(TType::STRUCT, count($this->set_field));
        {
          foreach ($this->set_field as $iter67 => $iter68)
          {
            if (is_scalar($iter68)) {
            $xfer += $iter67->write($output);
            } else {
            $xfer += $iter68->write($output);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_field !== null) {
      if (!is_array($this->list_field)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_field', TType::LST, 3);
      {
        $output->writeListBegin(TType::MAP, count($this->list_field));
        {
          foreach ($this->list_field as $iter69)
          {
            {
              $output->writeMapBegin(TType::SET, TType::MAP, count($iter69));
              {
                foreach ($iter69 as $kiter70 => $viter71)
                {
                  {
                    $output->writeSetBegin(TType::I32, count($kiter70));
                    {
                      foreach ($kiter70 as $iter72 => $iter73)
                      {
                        if (is_scalar($iter73)) {
                        $xfer += $output->writeI32($iter72);
                        } else {
                        $xfer += $output->writeI32($iter73);
                        }
                      }
                    }
                    $output->writeSetEnd();
                  }
                  {
                    $output->writeMapBegin(TType::I32, TType::SET, count($viter71));
                    {
                      foreach ($viter71 as $kiter74 => $viter75)
                      {
                        $xfer += $output->writeI32($kiter74);
                        {
                          $output->writeSetBegin(TType::LST, count($viter75));
                          {
                            foreach ($viter75 as $iter76 => $iter77)
                            {
                              if (is_scalar($iter77)) {
                              {
                                $output->writeListBegin(TType::MAP, count($iter76));
                                {
                                  foreach ($iter76 as $iter78)
                                  {
                                    {
                                      $output->writeMapBegin(TType::STRUCT, TType::STRING, count($iter78));
                                      {
                                        foreach ($iter78 as $kiter79 => $viter80)
                                        {
                                          $xfer += $kiter79->write($output);
                                          $xfer += $output->writeString($viter80);
                                        }
                                      }
                                      $output->writeMapEnd();
                                    }
                                  }
                                }
                                $output->writeListEnd();
                              }
                              } else {
                              {
                                $output->writeListBegin(TType::MAP, count($iter77));
                                {
                                  foreach ($iter77 as $iter81)
                                  {
                                    {
                                      $output->writeMapBegin(TType::STRUCT, TType::STRING, count($iter81));
                                      {
                                        foreach ($iter81 as $kiter82 => $viter83)
                                        {
                                          $xfer += $kiter82->write($output);
                                          $xfer += $output->writeString($viter83);
                                        }
                                      }
                                      $output->writeMapEnd();
                                    }
                                  }
                                }
                                $output->writeListEnd();
                              }
                              }
                            }
                          }
                          $output->writeSetEnd();
                        }
                      }
                    }
                    $output->writeMapEnd();
                  }
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->binary_field !== null) {
      $xfer += $output->writeFieldBegin('binary_field', TType::STRING, 4);
      $xfer += $output->writeString($this->binary_field);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Xception extends TException {
  static $_TSPEC;

  /**
   * @var int
   */
  public $errorCode = null;
  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorCode',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorCode'])) {
        $this->errorCode = $vals['errorCode'];
      }
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'Xception';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->errorCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xception');
    if ($this->errorCode !== null) {
      $xfer += $output->writeFieldBegin('errorCode', TType::I32, 1);
      $xfer += $output->writeI32($this->errorCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 2);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Xception2 extends TException {
  static $_TSPEC;

  /**
   * @var int
   */
  public $errorCode = null;
  /**
   * @var \ThriftTest\Xtruct
   */
  public $struct_thing = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorCode',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'struct_thing',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Xtruct',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorCode'])) {
        $this->errorCode = $vals['errorCode'];
      }
      if (isset($vals['struct_thing'])) {
        $this->struct_thing = $vals['struct_thing'];
      }
    }
  }

  public function getName() {
    return 'Xception2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->errorCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->struct_thing = new \ThriftTest\Xtruct();
            $xfer += $this->struct_thing->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xception2');
    if ($this->errorCode !== null) {
      $xfer += $output->writeFieldBegin('errorCode', TType::I32, 1);
      $xfer += $output->writeI32($this->errorCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->struct_thing !== null) {
      if (!is_object($this->struct_thing)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('struct_thing', TType::STRUCT, 2);
      $xfer += $this->struct_thing->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class EmptyStruct {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'EmptyStruct';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('EmptyStruct');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OneField {
  static $_TSPEC;

  /**
   * @var \ThriftTest\EmptyStruct
   */
  public $field = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'field',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\EmptyStruct',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['field'])) {
        $this->field = $vals['field'];
      }
    }
  }

  public function getName() {
    return 'OneField';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->field = new \ThriftTest\EmptyStruct();
            $xfer += $this->field->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OneField');
    if ($this->field !== null) {
      if (!is_object($this->field)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('field', TType::STRUCT, 1);
      $xfer += $this->field->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class VersioningTestV1 {
  static $_TSPEC;

  /**
   * @var int
   */
  public $begin_in_both = null;
  /**
   * @var string
   */
  public $old_string = null;
  /**
   * @var int
   */
  public $end_in_both = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'begin_in_both',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'old_string',
          'type' => TType::STRING,
          ),
        12 => array(
          'var' => 'end_in_both',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['begin_in_both'])) {
        $this->begin_in_both = $vals['begin_in_both'];
      }
      if (isset($vals['old_string'])) {
        $this->old_string = $vals['old_string'];
      }
      if (isset($vals['end_in_both'])) {
        $this->end_in_both = $vals['end_in_both'];
      }
    }
  }

  public function getName() {
    return 'VersioningTestV1';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->begin_in_both);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->old_string);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->end_in_both);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('VersioningTestV1');
    if ($this->begin_in_both !== null) {
      $xfer += $output->writeFieldBegin('begin_in_both', TType::I32, 1);
      $xfer += $output->writeI32($this->begin_in_both);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->old_string !== null) {
      $xfer += $output->writeFieldBegin('old_string', TType::STRING, 3);
      $xfer += $output->writeString($this->old_string);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->end_in_both !== null) {
      $xfer += $output->writeFieldBegin('end_in_both', TType::I32, 12);
      $xfer += $output->writeI32($this->end_in_both);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class VersioningTestV2 {
  static $_TSPEC;

  /**
   * @var int
   */
  public $begin_in_both = null;
  /**
   * @var int
   */
  public $newint = null;
  /**
   * @var int
   */
  public $newbyte = null;
  /**
   * @var int
   */
  public $newshort = null;
  /**
   * @var int
   */
  public $newlong = null;
  /**
   * @var double
   */
  public $newdouble = null;
  /**
   * @var \ThriftTest\Bonk
   */
  public $newstruct = null;
  /**
   * @var int[]
   */
  public $newlist = null;
  /**
   * @var int[]
   */
  public $newset = null;
  /**
   * @var array
   */
  public $newmap = null;
  /**
   * @var string
   */
  public $newstring = null;
  /**
   * @var int
   */
  public $end_in_both = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'begin_in_both',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'newint',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'newbyte',
          'type' => TType::BYTE,
          ),
        4 => array(
          'var' => 'newshort',
          'type' => TType::I16,
          ),
        5 => array(
          'var' => 'newlong',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'newdouble',
          'type' => TType::DOUBLE,
          ),
        7 => array(
          'var' => 'newstruct',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Bonk',
          ),
        8 => array(
          'var' => 'newlist',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        9 => array(
          'var' => 'newset',
          'type' => TType::SET,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        10 => array(
          'var' => 'newmap',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        11 => array(
          'var' => 'newstring',
          'type' => TType::STRING,
          ),
        12 => array(
          'var' => 'end_in_both',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['begin_in_both'])) {
        $this->begin_in_both = $vals['begin_in_both'];
      }
      if (isset($vals['newint'])) {
        $this->newint = $vals['newint'];
      }
      if (isset($vals['newbyte'])) {
        $this->newbyte = $vals['newbyte'];
      }
      if (isset($vals['newshort'])) {
        $this->newshort = $vals['newshort'];
      }
      if (isset($vals['newlong'])) {
        $this->newlong = $vals['newlong'];
      }
      if (isset($vals['newdouble'])) {
        $this->newdouble = $vals['newdouble'];
      }
      if (isset($vals['newstruct'])) {
        $this->newstruct = $vals['newstruct'];
      }
      if (isset($vals['newlist'])) {
        $this->newlist = $vals['newlist'];
      }
      if (isset($vals['newset'])) {
        $this->newset = $vals['newset'];
      }
      if (isset($vals['newmap'])) {
        $this->newmap = $vals['newmap'];
      }
      if (isset($vals['newstring'])) {
        $this->newstring = $vals['newstring'];
      }
      if (isset($vals['end_in_both'])) {
        $this->end_in_both = $vals['end_in_both'];
      }
    }
  }

  public function getName() {
    return 'VersioningTestV2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->begin_in_both);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->newint);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->newbyte);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->newshort);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->newlong);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->newdouble);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->newstruct = new \ThriftTest\Bonk();
            $xfer += $this->newstruct->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::LST) {
            $this->newlist = array();
            $_size84 = 0;
            $_etype87 = 0;
            $xfer += $input->readListBegin($_etype87, $_size84);
            for ($_i88 = 0; $_i88 < $_size84; ++$_i88)
            {
              $elem89 = null;
              $xfer += $input->readI32($elem89);
              $this->newlist []= $elem89;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::SET) {
            $this->newset = array();
            $_size90 = 0;
            $_etype93 = 0;
            $xfer += $input->readSetBegin($_etype93, $_size90);
            for ($_i94 = 0; $_i94 < $_size90; ++$_i94)
            {
              $elem95 = null;
              $xfer += $input->readI32($elem95);
              if (is_scalar($elem95)) {
                $this->newset[$elem95] = true;
              } else {
                $this->newset []= $elem95;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::MAP) {
            $this->newmap = array();
            $_size96 = 0;
            $_ktype97 = 0;
            $_vtype98 = 0;
            $xfer += $input->readMapBegin($_ktype97, $_vtype98, $_size96);
            for ($_i100 = 0; $_i100 < $_size96; ++$_i100)
            {
              $key101 = 0;
              $val102 = 0;
              $xfer += $input->readI32($key101);
              $xfer += $input->readI32($val102);
              $this->newmap[$key101] = $val102;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->newstring);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->end_in_both);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('VersioningTestV2');
    if ($this->begin_in_both !== null) {
      $xfer += $output->writeFieldBegin('begin_in_both', TType::I32, 1);
      $xfer += $output->writeI32($this->begin_in_both);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newint !== null) {
      $xfer += $output->writeFieldBegin('newint', TType::I32, 2);
      $xfer += $output->writeI32($this->newint);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newbyte !== null) {
      $xfer += $output->writeFieldBegin('newbyte', TType::BYTE, 3);
      $xfer += $output->writeByte($this->newbyte);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newshort !== null) {
      $xfer += $output->writeFieldBegin('newshort', TType::I16, 4);
      $xfer += $output->writeI16($this->newshort);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newlong !== null) {
      $xfer += $output->writeFieldBegin('newlong', TType::I64, 5);
      $xfer += $output->writeI64($this->newlong);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newdouble !== null) {
      $xfer += $output->writeFieldBegin('newdouble', TType::DOUBLE, 6);
      $xfer += $output->writeDouble($this->newdouble);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newstruct !== null) {
      if (!is_object($this->newstruct)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newstruct', TType::STRUCT, 7);
      $xfer += $this->newstruct->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newlist !== null) {
      if (!is_array($this->newlist)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newlist', TType::LST, 8);
      {
        $output->writeListBegin(TType::I32, count($this->newlist));
        {
          foreach ($this->newlist as $iter103)
          {
            $xfer += $output->writeI32($iter103);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newset !== null) {
      if (!is_array($this->newset)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newset', TType::SET, 9);
      {
        $output->writeSetBegin(TType::I32, count($this->newset));
        {
          foreach ($this->newset as $iter104 => $iter105)
          {
            if (is_scalar($iter105)) {
            $xfer += $output->writeI32($iter104);
            } else {
            $xfer += $output->writeI32($iter105);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newmap !== null) {
      if (!is_array($this->newmap)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newmap', TType::MAP, 10);
      {
        $output->writeMapBegin(TType::I32, TType::I32, count($this->newmap));
        {
          foreach ($this->newmap as $kiter106 => $viter107)
          {
            $xfer += $output->writeI32($kiter106);
            $xfer += $output->writeI32($viter107);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newstring !== null) {
      $xfer += $output->writeFieldBegin('newstring', TType::STRING, 11);
      $xfer += $output->writeString($this->newstring);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->end_in_both !== null) {
      $xfer += $output->writeFieldBegin('end_in_both', TType::I32, 12);
      $xfer += $output->writeI32($this->end_in_both);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListTypeVersioningV1 {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $myints = null;
  /**
   * @var string
   */
  public $hello = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'myints',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        2 => array(
          'var' => 'hello',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['myints'])) {
        $this->myints = $vals['myints'];
      }
      if (isset($vals['hello'])) {
        $this->hello = $vals['hello'];
      }
    }
  }

  public function getName() {
    return 'ListTypeVersioningV1';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->myints = array();
            $_size108 = 0;
            $_etype111 = 0;
            $xfer += $input->readListBegin($_etype111, $_size108);
            for ($_i112 = 0; $_i112 < $_size108; ++$_i112)
            {
              $elem113 = null;
              $xfer += $input->readI32($elem113);
              $this->myints []= $elem113;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hello);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListTypeVersioningV1');
    if ($this->myints !== null) {
      if (!is_array($this->myints)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('myints', TType::LST, 1);
      {
        $output->writeListBegin(TType::I32, count($this->myints));
        {
          foreach ($this->myints as $iter114)
          {
            $xfer += $output->writeI32($iter114);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hello !== null) {
      $xfer += $output->writeFieldBegin('hello', TType::STRING, 2);
      $xfer += $output->writeString($this->hello);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListTypeVersioningV2 {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $strings = null;
  /**
   * @var string
   */
  public $hello = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'strings',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'hello',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['strings'])) {
        $this->strings = $vals['strings'];
      }
      if (isset($vals['hello'])) {
        $this->hello = $vals['hello'];
      }
    }
  }

  public function getName() {
    return 'ListTypeVersioningV2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->strings = array();
            $_size115 = 0;
            $_etype118 = 0;
            $xfer += $input->readListBegin($_etype118, $_size115);
            for ($_i119 = 0; $_i119 < $_size115; ++$_i119)
            {
              $elem120 = null;
              $xfer += $input->readString($elem120);
              $this->strings []= $elem120;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hello);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListTypeVersioningV2');
    if ($this->strings !== null) {
      if (!is_array($this->strings)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('strings', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->strings));
        {
          foreach ($this->strings as $iter121)
          {
            $xfer += $output->writeString($iter121);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hello !== null) {
      $xfer += $output->writeFieldBegin('hello', TType::STRING, 2);
      $xfer += $output->writeString($this->hello);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GuessProtocolStruct {
  static $_TSPEC;

  /**
   * @var array
   */
  public $map_field = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        7 => array(
          'var' => 'map_field',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['map_field'])) {
        $this->map_field = $vals['map_field'];
      }
    }
  }

  public function getName() {
    return 'GuessProtocolStruct';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 7:
          if ($ftype == TType::MAP) {
            $this->map_field = array();
            $_size122 = 0;
            $_ktype123 = 0;
            $_vtype124 = 0;
            $xfer += $input->readMapBegin($_ktype123, $_vtype124, $_size122);
            for ($_i126 = 0; $_i126 < $_size122; ++$_i126)
            {
              $key127 = '';
              $val128 = '';
              $xfer += $input->readString($key127);
              $xfer += $input->readString($val128);
              $this->map_field[$key127] = $val128;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GuessProtocolStruct');
    if ($this->map_field !== null) {
      if (!is_array($this->map_field)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_field', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->map_field));
        {
          foreach ($this->map_field as $kiter129 => $viter130)
          {
            $xfer += $output->writeString($kiter129);
            $xfer += $output->writeString($viter130);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LargeDeltas {
  static $_TSPEC;

  /**
   * @var \ThriftTest\Bools
   */
  public $b1 = null;
  /**
   * @var \ThriftTest\Bools
   */
  public $b10 = null;
  /**
   * @var \ThriftTest\Bools
   */
  public $b100 = null;
  /**
   * @var bool
   */
  public $check_true = null;
  /**
   * @var \ThriftTest\Bools
   */
  public $b1000 = null;
  /**
   * @var bool
   */
  public $check_false = null;
  /**
   * @var \ThriftTest\VersioningTestV2
   */
  public $vertwo2000 = null;
  /**
   * @var string[]
   */
  public $a_set2500 = null;
  /**
   * @var \ThriftTest\VersioningTestV2
   */
  public $vertwo3000 = null;
  /**
   * @var int[]
   */
  public $big_numbers = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'b1',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Bools',
          ),
        10 => array(
          'var' => 'b10',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Bools',
          ),
        100 => array(
          'var' => 'b100',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Bools',
          ),
        500 => array(
          'var' => 'check_true',
          'type' => TType::BOOL,
          ),
        1000 => array(
          'var' => 'b1000',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Bools',
          ),
        1500 => array(
          'var' => 'check_false',
          'type' => TType::BOOL,
          ),
        2000 => array(
          'var' => 'vertwo2000',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\VersioningTestV2',
          ),
        2500 => array(
          'var' => 'a_set2500',
          'type' => TType::SET,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3000 => array(
          'var' => 'vertwo3000',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\VersioningTestV2',
          ),
        4000 => array(
          'var' => 'big_numbers',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['b1'])) {
        $this->b1 = $vals['b1'];
      }
      if (isset($vals['b10'])) {
        $this->b10 = $vals['b10'];
      }
      if (isset($vals['b100'])) {
        $this->b100 = $vals['b100'];
      }
      if (isset($vals['check_true'])) {
        $this->check_true = $vals['check_true'];
      }
      if (isset($vals['b1000'])) {
        $this->b1000 = $vals['b1000'];
      }
      if (isset($vals['check_false'])) {
        $this->check_false = $vals['check_false'];
      }
      if (isset($vals['vertwo2000'])) {
        $this->vertwo2000 = $vals['vertwo2000'];
      }
      if (isset($vals['a_set2500'])) {
        $this->a_set2500 = $vals['a_set2500'];
      }
      if (isset($vals['vertwo3000'])) {
        $this->vertwo3000 = $vals['vertwo3000'];
      }
      if (isset($vals['big_numbers'])) {
        $this->big_numbers = $vals['big_numbers'];
      }
    }
  }

  public function getName() {
    return 'LargeDeltas';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->b1 = new \ThriftTest\Bools();
            $xfer += $this->b1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->b10 = new \ThriftTest\Bools();
            $xfer += $this->b10->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 100:
          if ($ftype == TType::STRUCT) {
            $this->b100 = new \ThriftTest\Bools();
            $xfer += $this->b100->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 500:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->check_true);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1000:
          if ($ftype == TType::STRUCT) {
            $this->b1000 = new \ThriftTest\Bools();
            $xfer += $this->b1000->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1500:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->check_false);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2000:
          if ($ftype == TType::STRUCT) {
            $this->vertwo2000 = new \ThriftTest\VersioningTestV2();
            $xfer += $this->vertwo2000->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2500:
          if ($ftype == TType::SET) {
            $this->a_set2500 = array();
            $_size131 = 0;
            $_etype134 = 0;
            $xfer += $input->readSetBegin($_etype134, $_size131);
            for ($_i135 = 0; $_i135 < $_size131; ++$_i135)
            {
              $elem136 = null;
              $xfer += $input->readString($elem136);
              if (is_scalar($elem136)) {
                $this->a_set2500[$elem136] = true;
              } else {
                $this->a_set2500 []= $elem136;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3000:
          if ($ftype == TType::STRUCT) {
            $this->vertwo3000 = new \ThriftTest\VersioningTestV2();
            $xfer += $this->vertwo3000->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4000:
          if ($ftype == TType::LST) {
            $this->big_numbers = array();
            $_size137 = 0;
            $_etype140 = 0;
            $xfer += $input->readListBegin($_etype140, $_size137);
            for ($_i141 = 0; $_i141 < $_size137; ++$_i141)
            {
              $elem142 = null;
              $xfer += $input->readI32($elem142);
              $this->big_numbers []= $elem142;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LargeDeltas');
    if ($this->b1 !== null) {
      if (!is_object($this->b1)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('b1', TType::STRUCT, 1);
      $xfer += $this->b1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->b10 !== null) {
      if (!is_object($this->b10)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('b10', TType::STRUCT, 10);
      $xfer += $this->b10->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->b100 !== null) {
      if (!is_object($this->b100)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('b100', TType::STRUCT, 100);
      $xfer += $this->b100->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->check_true !== null) {
      $xfer += $output->writeFieldBegin('check_true', TType::BOOL, 500);
      $xfer += $output->writeBool($this->check_true);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->b1000 !== null) {
      if (!is_object($this->b1000)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('b1000', TType::STRUCT, 1000);
      $xfer += $this->b1000->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->check_false !== null) {
      $xfer += $output->writeFieldBegin('check_false', TType::BOOL, 1500);
      $xfer += $output->writeBool($this->check_false);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->vertwo2000 !== null) {
      if (!is_object($this->vertwo2000)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('vertwo2000', TType::STRUCT, 2000);
      $xfer += $this->vertwo2000->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->a_set2500 !== null) {
      if (!is_array($this->a_set2500)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('a_set2500', TType::SET, 2500);
      {
        $output->writeSetBegin(TType::STRING, count($this->a_set2500));
        {
          foreach ($this->a_set2500 as $iter143 => $iter144)
          {
            if (is_scalar($iter144)) {
            $xfer += $output->writeString($iter143);
            } else {
            $xfer += $output->writeString($iter144);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->vertwo3000 !== null) {
      if (!is_object($this->vertwo3000)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('vertwo3000', TType::STRUCT, 3000);
      $xfer += $this->vertwo3000->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->big_numbers !== null) {
      if (!is_array($this->big_numbers)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('big_numbers', TType::LST, 4000);
      {
        $output->writeListBegin(TType::I32, count($this->big_numbers));
        {
          foreach ($this->big_numbers as $iter145)
          {
            $xfer += $output->writeI32($iter145);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NestedListsI32x2 {
  static $_TSPEC;

  /**
   * @var (int[])[]
   */
  public $integerlist = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'integerlist',
          'type' => TType::LST,
          'etype' => TType::LST,
          'elem' => array(
            'type' => TType::LST,
            'etype' => TType::I32,
            'elem' => array(
              'type' => TType::I32,
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['integerlist'])) {
        $this->integerlist = $vals['integerlist'];
      }
    }
  }

  public function getName() {
    return 'NestedListsI32x2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->integerlist = array();
            $_size146 = 0;
            $_etype149 = 0;
            $xfer += $input->readListBegin($_etype149, $_size146);
            for ($_i150 = 0; $_i150 < $_size146; ++$_i150)
            {
              $elem151 = null;
              $elem151 = array();
              $_size152 = 0;
              $_etype155 = 0;
              $xfer += $input->readListBegin($_etype155, $_size152);
              for ($_i156 = 0; $_i156 < $_size152; ++$_i156)
              {
                $elem157 = null;
                $xfer += $input->readI32($elem157);
                $elem151 []= $elem157;
              }
              $xfer += $input->readListEnd();
              $this->integerlist []= $elem151;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NestedListsI32x2');
    if ($this->integerlist !== null) {
      if (!is_array($this->integerlist)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('integerlist', TType::LST, 1);
      {
        $output->writeListBegin(TType::LST, count($this->integerlist));
        {
          foreach ($this->integerlist as $iter158)
          {
            {
              $output->writeListBegin(TType::I32, count($iter158));
              {
                foreach ($iter158 as $iter159)
                {
                  $xfer += $output->writeI32($iter159);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NestedListsI32x3 {
  static $_TSPEC;

  /**
   * @var ((int[])[])[]
   */
  public $integerlist = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'integerlist',
          'type' => TType::LST,
          'etype' => TType::LST,
          'elem' => array(
            'type' => TType::LST,
            'etype' => TType::LST,
            'elem' => array(
              'type' => TType::LST,
              'etype' => TType::I32,
              'elem' => array(
                'type' => TType::I32,
                ),
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['integerlist'])) {
        $this->integerlist = $vals['integerlist'];
      }
    }
  }

  public function getName() {
    return 'NestedListsI32x3';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->integerlist = array();
            $_size160 = 0;
            $_etype163 = 0;
            $xfer += $input->readListBegin($_etype163, $_size160);
            for ($_i164 = 0; $_i164 < $_size160; ++$_i164)
            {
              $elem165 = null;
              $elem165 = array();
              $_size166 = 0;
              $_etype169 = 0;
              $xfer += $input->readListBegin($_etype169, $_size166);
              for ($_i170 = 0; $_i170 < $_size166; ++$_i170)
              {
                $elem171 = null;
                $elem171 = array();
                $_size172 = 0;
                $_etype175 = 0;
                $xfer += $input->readListBegin($_etype175, $_size172);
                for ($_i176 = 0; $_i176 < $_size172; ++$_i176)
                {
                  $elem177 = null;
                  $xfer += $input->readI32($elem177);
                  $elem171 []= $elem177;
                }
                $xfer += $input->readListEnd();
                $elem165 []= $elem171;
              }
              $xfer += $input->readListEnd();
              $this->integerlist []= $elem165;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NestedListsI32x3');
    if ($this->integerlist !== null) {
      if (!is_array($this->integerlist)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('integerlist', TType::LST, 1);
      {
        $output->writeListBegin(TType::LST, count($this->integerlist));
        {
          foreach ($this->integerlist as $iter178)
          {
            {
              $output->writeListBegin(TType::LST, count($iter178));
              {
                foreach ($iter178 as $iter179)
                {
                  {
                    $output->writeListBegin(TType::I32, count($iter179));
                    {
                      foreach ($iter179 as $iter180)
                      {
                        $xfer += $output->writeI32($iter180);
                      }
                    }
                    $output->writeListEnd();
                  }
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NestedMixedx2 {
  static $_TSPEC;

  /**
   * @var (int[])[]
   */
  public $int_set_list = null;
  /**
   * @var array
   */
  public $map_int_strset = null;
  /**
   * @var (array)[]
   */
  public $map_int_strset_list = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'int_set_list',
          'type' => TType::LST,
          'etype' => TType::SET,
          'elem' => array(
            'type' => TType::SET,
            'etype' => TType::I32,
            'elem' => array(
              'type' => TType::I32,
              ),
            ),
          ),
        2 => array(
          'var' => 'map_int_strset',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::SET,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::SET,
            'etype' => TType::STRING,
            'elem' => array(
              'type' => TType::STRING,
              ),
            ),
          ),
        3 => array(
          'var' => 'map_int_strset_list',
          'type' => TType::LST,
          'etype' => TType::MAP,
          'elem' => array(
            'type' => TType::MAP,
            'ktype' => TType::I32,
            'vtype' => TType::SET,
            'key' => array(
              'type' => TType::I32,
            ),
            'val' => array(
              'type' => TType::SET,
              'etype' => TType::STRING,
              'elem' => array(
                'type' => TType::STRING,
                ),
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['int_set_list'])) {
        $this->int_set_list = $vals['int_set_list'];
      }
      if (isset($vals['map_int_strset'])) {
        $this->map_int_strset = $vals['map_int_strset'];
      }
      if (isset($vals['map_int_strset_list'])) {
        $this->map_int_strset_list = $vals['map_int_strset_list'];
      }
    }
  }

  public function getName() {
    return 'NestedMixedx2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->int_set_list = array();
            $_size181 = 0;
            $_etype184 = 0;
            $xfer += $input->readListBegin($_etype184, $_size181);
            for ($_i185 = 0; $_i185 < $_size181; ++$_i185)
            {
              $elem186 = null;
              $elem186 = array();
              $_size187 = 0;
              $_etype190 = 0;
              $xfer += $input->readSetBegin($_etype190, $_size187);
              for ($_i191 = 0; $_i191 < $_size187; ++$_i191)
              {
                $elem192 = null;
                $xfer += $input->readI32($elem192);
                if (is_scalar($elem192)) {
                  $elem186[$elem192] = true;
                } else {
                  $elem186 []= $elem192;
                }
              }
              $xfer += $input->readSetEnd();
              $this->int_set_list []= $elem186;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->map_int_strset = array();
            $_size193 = 0;
            $_ktype194 = 0;
            $_vtype195 = 0;
            $xfer += $input->readMapBegin($_ktype194, $_vtype195, $_size193);
            for ($_i197 = 0; $_i197 < $_size193; ++$_i197)
            {
              $key198 = 0;
              $val199 = array();
              $xfer += $input->readI32($key198);
              $val199 = array();
              $_size200 = 0;
              $_etype203 = 0;
              $xfer += $input->readSetBegin($_etype203, $_size200);
              for ($_i204 = 0; $_i204 < $_size200; ++$_i204)
              {
                $elem205 = null;
                $xfer += $input->readString($elem205);
                if (is_scalar($elem205)) {
                  $val199[$elem205] = true;
                } else {
                  $val199 []= $elem205;
                }
              }
              $xfer += $input->readSetEnd();
              $this->map_int_strset[$key198] = $val199;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->map_int_strset_list = array();
            $_size206 = 0;
            $_etype209 = 0;
            $xfer += $input->readListBegin($_etype209, $_size206);
            for ($_i210 = 0; $_i210 < $_size206; ++$_i210)
            {
              $elem211 = null;
              $elem211 = array();
              $_size212 = 0;
              $_ktype213 = 0;
              $_vtype214 = 0;
              $xfer += $input->readMapBegin($_ktype213, $_vtype214, $_size212);
              for ($_i216 = 0; $_i216 < $_size212; ++$_i216)
              {
                $key217 = 0;
                $val218 = array();
                $xfer += $input->readI32($key217);
                $val218 = array();
                $_size219 = 0;
                $_etype222 = 0;
                $xfer += $input->readSetBegin($_etype222, $_size219);
                for ($_i223 = 0; $_i223 < $_size219; ++$_i223)
                {
                  $elem224 = null;
                  $xfer += $input->readString($elem224);
                  if (is_scalar($elem224)) {
                    $val218[$elem224] = true;
                  } else {
                    $val218 []= $elem224;
                  }
                }
                $xfer += $input->readSetEnd();
                $elem211[$key217] = $val218;
              }
              $xfer += $input->readMapEnd();
              $this->map_int_strset_list []= $elem211;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NestedMixedx2');
    if ($this->int_set_list !== null) {
      if (!is_array($this->int_set_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('int_set_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::SET, count($this->int_set_list));
        {
          foreach ($this->int_set_list as $iter225)
          {
            {
              $output->writeSetBegin(TType::I32, count($iter225));
              {
                foreach ($iter225 as $iter226 => $iter227)
                {
                  if (is_scalar($iter227)) {
                  $xfer += $output->writeI32($iter226);
                  } else {
                  $xfer += $output->writeI32($iter227);
                  }
                }
              }
              $output->writeSetEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_int_strset !== null) {
      if (!is_array($this->map_int_strset)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_int_strset', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::I32, TType::SET, count($this->map_int_strset));
        {
          foreach ($this->map_int_strset as $kiter228 => $viter229)
          {
            $xfer += $output->writeI32($kiter228);
            {
              $output->writeSetBegin(TType::STRING, count($viter229));
              {
                foreach ($viter229 as $iter230 => $iter231)
                {
                  if (is_scalar($iter231)) {
                  $xfer += $output->writeString($iter230);
                  } else {
                  $xfer += $output->writeString($iter231);
                  }
                }
              }
              $output->writeSetEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_int_strset_list !== null) {
      if (!is_array($this->map_int_strset_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_int_strset_list', TType::LST, 3);
      {
        $output->writeListBegin(TType::MAP, count($this->map_int_strset_list));
        {
          foreach ($this->map_int_strset_list as $iter232)
          {
            {
              $output->writeMapBegin(TType::I32, TType::SET, count($iter232));
              {
                foreach ($iter232 as $kiter233 => $viter234)
                {
                  $xfer += $output->writeI32($kiter233);
                  {
                    $output->writeSetBegin(TType::STRING, count($viter234));
                    {
                      foreach ($viter234 as $iter235 => $iter236)
                      {
                        if (is_scalar($iter236)) {
                        $xfer += $output->writeString($iter235);
                        } else {
                        $xfer += $output->writeString($iter236);
                        }
                      }
                    }
                    $output->writeSetEnd();
                  }
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListBonks {
  static $_TSPEC;

  /**
   * @var \ThriftTest\Bonk[]
   */
  public $bonk = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'bonk',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ThriftTest\Bonk',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['bonk'])) {
        $this->bonk = $vals['bonk'];
      }
    }
  }

  public function getName() {
    return 'ListBonks';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->bonk = array();
            $_size237 = 0;
            $_etype240 = 0;
            $xfer += $input->readListBegin($_etype240, $_size237);
            for ($_i241 = 0; $_i241 < $_size237; ++$_i241)
            {
              $elem242 = null;
              $elem242 = new \ThriftTest\Bonk();
              $xfer += $elem242->read($input);
              $this->bonk []= $elem242;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListBonks');
    if ($this->bonk !== null) {
      if (!is_array($this->bonk)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('bonk', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->bonk));
        {
          foreach ($this->bonk as $iter243)
          {
            $xfer += $iter243->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NestedListsBonk {
  static $_TSPEC;

  /**
   * @var ((\ThriftTest\Bonk[])[])[]
   */
  public $bonk = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'bonk',
          'type' => TType::LST,
          'etype' => TType::LST,
          'elem' => array(
            'type' => TType::LST,
            'etype' => TType::LST,
            'elem' => array(
              'type' => TType::LST,
              'etype' => TType::STRUCT,
              'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\ThriftTest\Bonk',
                ),
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['bonk'])) {
        $this->bonk = $vals['bonk'];
      }
    }
  }

  public function getName() {
    return 'NestedListsBonk';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->bonk = array();
            $_size244 = 0;
            $_etype247 = 0;
            $xfer += $input->readListBegin($_etype247, $_size244);
            for ($_i248 = 0; $_i248 < $_size244; ++$_i248)
            {
              $elem249 = null;
              $elem249 = array();
              $_size250 = 0;
              $_etype253 = 0;
              $xfer += $input->readListBegin($_etype253, $_size250);
              for ($_i254 = 0; $_i254 < $_size250; ++$_i254)
              {
                $elem255 = null;
                $elem255 = array();
                $_size256 = 0;
                $_etype259 = 0;
                $xfer += $input->readListBegin($_etype259, $_size256);
                for ($_i260 = 0; $_i260 < $_size256; ++$_i260)
                {
                  $elem261 = null;
                  $elem261 = new \ThriftTest\Bonk();
                  $xfer += $elem261->read($input);
                  $elem255 []= $elem261;
                }
                $xfer += $input->readListEnd();
                $elem249 []= $elem255;
              }
              $xfer += $input->readListEnd();
              $this->bonk []= $elem249;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NestedListsBonk');
    if ($this->bonk !== null) {
      if (!is_array($this->bonk)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('bonk', TType::LST, 1);
      {
        $output->writeListBegin(TType::LST, count($this->bonk));
        {
          foreach ($this->bonk as $iter262)
          {
            {
              $output->writeListBegin(TType::LST, count($iter262));
              {
                foreach ($iter262 as $iter263)
                {
                  {
                    $output->writeListBegin(TType::STRUCT, count($iter263));
                    {
                      foreach ($iter263 as $iter264)
                      {
                        $xfer += $iter264->write($output);
                      }
                    }
                    $output->writeListEnd();
                  }
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BoolTest {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $b = true;
  /**
   * @var string
   */
  public $s = "true";

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'b',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 's',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['b'])) {
        $this->b = $vals['b'];
      }
      if (isset($vals['s'])) {
        $this->s = $vals['s'];
      }
    }
  }

  public function getName() {
    return 'BoolTest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->b);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->s);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BoolTest');
    if ($this->b !== null) {
      $xfer += $output->writeFieldBegin('b', TType::BOOL, 1);
      $xfer += $output->writeBool($this->b);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->s !== null) {
      $xfer += $output->writeFieldBegin('s', TType::STRING, 2);
      $xfer += $output->writeString($this->s);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class StructA {
  static $_TSPEC;

  /**
   * @var string
   */
  public $s = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 's',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['s'])) {
        $this->s = $vals['s'];
      }
    }
  }

  public function getName() {
    return 'StructA';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->s);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('StructA');
    if ($this->s !== null) {
      $xfer += $output->writeFieldBegin('s', TType::STRING, 1);
      $xfer += $output->writeString($this->s);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class StructB {
  static $_TSPEC;

  /**
   * @var \ThriftTest\StructA
   */
  public $aa = null;
  /**
   * @var \ThriftTest\StructA
   */
  public $ab = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'aa',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\StructA',
          ),
        2 => array(
          'var' => 'ab',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\StructA',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['aa'])) {
        $this->aa = $vals['aa'];
      }
      if (isset($vals['ab'])) {
        $this->ab = $vals['ab'];
      }
    }
  }

  public function getName() {
    return 'StructB';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->aa = new \ThriftTest\StructA();
            $xfer += $this->aa->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ab = new \ThriftTest\StructA();
            $xfer += $this->ab->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('StructB');
    if ($this->aa !== null) {
      if (!is_object($this->aa)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('aa', TType::STRUCT, 1);
      $xfer += $this->aa->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ab !== null) {
      if (!is_object($this->ab)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ab', TType::STRUCT, 2);
      $xfer += $this->ab->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

final class Constant extends \Thrift\Type\TConstant {
  static protected $myNumberz;

  static protected function init_myNumberz() {
    return     1;
  }
}


